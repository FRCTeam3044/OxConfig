package me.nabdev.oxconfig;

import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import com.amihaiemil.eoyaml.Yaml;
import com.amihaiemil.eoyaml.YamlMapping;
import com.amihaiemil.eoyaml.YamlMappingBuilder;
import com.amihaiemil.eoyaml.YamlPrinter;
import com.amihaiemil.eoyaml.extensions.MergedYamlMapping;

import edu.wpi.first.wpilibj.Filesystem;

/**
 * A flexible, dynamic YAML based automatic configuration system for FRC robots
 */
public class OxConfig {
    static YamlMapping config;
    private static HashMap<String, Configurable<?>> configValues = new HashMap<String, Configurable<?>>();
    private static HashMap<String, ConfigurableClass> configurableClasses = new HashMap<String, ConfigurableClass>();
    private static HashMap<String, ConfigurableParameter<?>> configurableParameters = new HashMap<String, ConfigurableParameter<?>>();

    private static boolean hasModified = false;
    private static boolean hasReadFromFile = false;
    static boolean pendingNTUpdate = false;
    static boolean hasInitialized = false;

    /**
     * The current modeSelector, used to determine which config values to use
     */
    public static ModeSelector modeSelector = new ModeSelector();
    /**
     * Updates all the configurable parameters/configurable classes (NOT FROM FILE, use reloadFromDisk() instead)
     */
    public static void reload(){
        if(!hasReadFromFile){
            reloadFromFile();
            hasReadFromFile = true;
        }
        reloadConfig();
        if(hasModified){
            writeFiles();
            hasModified = false;
        }
        hasInitialized = true;
    }

    /**
     * Reloads all values from the config file and updates the configurable parameters/configurable classes
     */
    public static void reloadFromDisk(){
        reloadFromFile();
        reloadConfig();
        if(hasModified){
            writeFiles();
            hasModified = false;
        }
        hasInitialized = true;
    }

    /**
     * Missing config keys will be added to the config file automatically,
     * this function will write out those autogenerated keys to a file
     */
    public static void writeFiles(){
        try {
            final YamlPrinter printer = Yaml.createYamlPrinter(
                new FileWriter(Filesystem.getDeployDirectory() + "/config.yml")
            );
            printer.print(config);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * Register a class to be automatically configured (should be called in configurable class constructor).
     * This is automatically handled in ConfigurablePIDController and ConfigurableSparkPIDController.
     * @param configurableClass the class to register
     */
    public static void registerConfigurableClass(ConfigurableClass configurableClass){
        configurableClasses.put(configurableClass.getKey(), configurableClass);
        ArrayList<ConfigurableClassParam<?>> parameters = configurableClass.getParameters();
        parameters.forEach(parameter -> {
            registerClassParameter(
                parameter.getKey(),
                parameter
            );
        });
    }

    /**
     * Not for use by the user: 
     * Sets up a config value to be automatically configured (Automatically handled by ConfigurableParameter)
     * @param key the yaml key the value will be found under in config.yml (in deploy folder)
     * @param parameter the parameter to update
     */
    public static void registerParameter(String key, ConfigurableParameter<?> parameter){
        configValues.put(key, parameter);
        configurableParameters.put(key, parameter);
        reload();
    }

    /**
     * Not for use by the user:
     * Sets up a configurable class param  automatically configured (Automatically handled by ConfigurableClassParam)
     * @param key the yaml key the value will be found under in config.yml (in deploy folder)
     * @param parameter the parameter to update
     */
    public static void registerClassParameter(String key, ConfigurableClassParam<?> parameter){
        configValues.put(key, parameter);
        reload();
    }

    private static void reloadFromFile(){
        try {
            config = Yaml.createYamlInput(new File(Filesystem.getDeployDirectory() + "/config.yml")).readYamlMapping();
            pendingNTUpdate = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void reloadConfig(){
        for(String key : configValues.keySet()){
            String[] keys = key.split("/");
            if(keys[0].equalsIgnoreCase("root")){
                String newKey = String.join("/", Arrays.copyOfRange(keys, 1, keys.length));
                ensureExists(newKey, configValues.get(key).get().toString());
                setValue(configValues.get(key), keys[keys.length - 1], getNestedValue(newKey, config), key);
            } else {
                for(String mode : ModeSelector.modes) {
                    ensureExists(mode + "/" + key, configValues.get(key).get().toString());
                }
                setValue(configValues.get(key), keys[keys.length - 1], getNestedValue(modeSelector.getMode() + "/" + key, config), key);
            }
        }
    }
    @SuppressWarnings("unchecked")
    private static void setValue(Configurable<?> obj, String key, YamlMapping map, String fullKey){
        try {
            if(obj.get() instanceof Double){
                ((Configurable<Double>)obj).set(Double.valueOf(map.doubleNumber(key)));
            } else if(obj.get() instanceof Integer){
                ((Configurable<Integer>)obj).set(Integer.valueOf(map.integer(key)));
            } else if(obj.get() instanceof Boolean){
                ((Configurable<Boolean>)obj).set(Boolean.valueOf(map.string(key)));
            } else if(obj.get() instanceof String){
                ((Configurable<String>)obj).set(String.valueOf(map.string(key)));
            } else if(obj.get() instanceof Short){
                ((Configurable<Short>)obj).set(Short.valueOf(map.string(key)));
            } else if(obj.get() instanceof Long){
                ((Configurable<Long>)obj).set(Long.valueOf(map.longNumber(key)));
            } 
            else {
                System.out.println("Unknown OxConfig type: " + obj.get().getClass().getName());
            }
        } catch (Exception e) {
            System.out.println("Error setting config value: " + fullKey);
            e.printStackTrace();
        }
    }

    /**
     * Ensures that the given key exists in the given YamlMapping, and if it does not, adds it with the given default value. 
     * Will not overwrite any existing values, even in higher levels of the heirarchy
     * @param key The key to ensure exists, in the form of "key1/key2/key3"
     * @param defaultVal The default value to use if the key does not exist
     * @return A new YamlMapping that is garunteed to have the given key
     */
    private static void ensureExists(String key, String defaultVal) {
        String[] keys = key.split("/");
        // If the key already exists, return the original mapping
        YamlMapping nested = getNestedValue(key, config);
        if(nested != null && nested.string(keys[keys.length - 1]) != null){
            return;
        }
        hasModified = true;
        pendingNTUpdate = true;

        YamlMappingBuilder newMap = Yaml.createYamlMappingBuilder();
        newMap = newMap.add(keys[keys.length - 1], Yaml.createYamlScalarBuilder()
            .addLine(defaultVal)
            .buildPlainScalar(
                "Auto-generated"
            ));
            
        // Iterate backwards through the keys, creating the heirarchy from the bottom up
        for(int i = keys.length - 2; i >= 0; i--){
            newMap = Yaml.createYamlMappingBuilder().add(keys[i], newMap.build());
        }
        config = new MergedYamlMapping(config, newMap.build(), true);
    }

    /**
     * Change the value of a key
     * @param key The key to change, in the form of "key1/key2/key3"
     * @param newValue The new value
     * @param source The YamlMapping to check
     * @return A new YamlMapping that is garunteed to have the given key
     */
    private static YamlMapping modifyValue(String key, String newValue, String comment, final YamlMapping source) {
        String[] keys = key.split("/");
        hasModified = true;
        pendingNTUpdate = true;

        YamlMappingBuilder newMap = Yaml.createYamlMappingBuilder();
        newMap = newMap.add(keys[keys.length - 1], Yaml.createYamlScalarBuilder()
            .addLine(newValue)
            .buildPlainScalar(comment)
        );

        // Iterate backwards through the keys, creating the hierarchy from the bottom up
        for(int i = keys.length - 2; i >= 0; i--){
            newMap = Yaml.createYamlMappingBuilder().add(keys[i], newMap.build());
        }
        YamlMapping test = new MergedYamlMapping(source, newMap.build(), true);
        return test;
    }

    /**
     * Returns the mapping that is one step up in the hierarchy from the given key
     * @param key The key to get, in the form of "key1/key2/key3"
     * @param source The YamlMapping to get the key from
     * @return The nested YamlMapping, null if not found
     */
    static YamlMapping getNestedValue(String key, YamlMapping source){
        String[] keys = key.split("/");
        YamlMapping map = source;
        for(int i = 0; i < keys.length - 1; i++){
            if(map == null) return map;
            map = map.yamlMapping(keys[i]);
        }
        return map;
    }


    /**
     * Reading/writing the config over NetworkTables, used for the tuning and config GUI's built in to our modified advantage scope.
     * OxConfig can be run without this if you aren't interested in these features. Designed to be run in periodic.
     */
    public static void runNTInterface(){
        handleKeySetter();
        if(pendingNTUpdate){
            pendingNTUpdate = false;
            NT4Interface.updateClasses(configurableClasses);
            NT4Interface.updateParameters(configurableParameters);
            NT4Interface.updateMode();
            NT4Interface.updateRaw(config);
        }
    }

    /**
     * Read the KeySetter and ModeSetter from NT to set
     */
    private static void handleKeySetter(){
        String keySetRaw = NT4Interface.getSetKeys();
        if(!keySetRaw.isEmpty()){
            String[] keySet = keySetRaw.split(",");
            for(int i = 0; i < ModeSelector.modes.length; i++){
                String mode = ModeSelector.modes[i];
                String key = keySet[0];
                if(!key.split(",")[0].equals("root")){
                    key = mode + "/" + keySet[0];
                }
                config = modifyValue(key, keySet[2 + i], keySet[1], config);
            }
            reload();
        }

        String modeSet = NT4Interface.getSetModes();
        if(Arrays.asList(ModeSelector.modes).contains(modeSet)){
            config = modifyValue("mode", modeSet, "Set Mode", config);
            reload();
        }
        
    }

    static String appendModeIfNotRoot(String key){
        String[] keys = key.split("/");
        if(keys[0].equalsIgnoreCase("root")){
            return String.join("/", Arrays.copyOfRange(keys, 1, keys.length));
        } else {
            return modeSelector.getMode() + "/" + key;
        }
    }
}
 