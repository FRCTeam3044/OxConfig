package me.nabdev.autoconfig;

import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.HashMap;
import com.amihaiemil.eoyaml.Yaml;
import com.amihaiemil.eoyaml.YamlMapping;
import com.amihaiemil.eoyaml.YamlMappingBuilder;
import com.amihaiemil.eoyaml.YamlPrinter;
import com.amihaiemil.eoyaml.extensions.MergedYamlMapping;

import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.RobotBase;

public class AutoConfig {
    private static YamlMapping config;
    private static HashMap<String, Configurable<?>> configValues = new HashMap<String, Configurable<?>>();
    private static HashMap<String, ConfigurableClass> configurableClasses = new HashMap<String, ConfigurableClass>();

    private static boolean hasModified = false;
    private static boolean hasReadFromFile = false;

    private static boolean pendingASUpdate = false;

    /**
     * Updates all the configurable parameters
     */
    public static void reload(){
        if(!hasReadFromFile){
            reloadFromFile();
            hasReadFromFile = true;
        }
        reloadConfig();
        if(hasModified){
            writeFiles();
            hasModified = false;
        }
    }

    /**
     * Reloads all values from the files and updates the configurable parameters
     */
    public static void reloadFromDisk(){
        reloadFromFile();
        reloadConfig();
        if(hasModified){
            writeFiles();
            hasModified = false;
        }
    }

    /**
     * Missing config keys will be added to the config file automatically,
     * this function will write out those autogenerated keys to a file
     */
    public static void writeFiles(){
        try {
            final YamlPrinter printer = Yaml.createYamlPrinter(
                new FileWriter(Filesystem.getDeployDirectory() + "/config.yml")
            );
            printer.print(config);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    
    public static void registerConfigurableClass(ConfigurableClass configurableClass){
        configurableClasses.put(configurableClass.getKey(), configurableClass);
        ArrayList<ConfigurableClassParam<?>> parameters = configurableClass.getParameters();
        parameters.forEach(parameter -> {
            registerParameter(
                parameter.getKey(),
                parameter,
                parameter.isSimRealSpecific()
            );
        });
    }

    /**
     * Not for use by the user: 
     * Sets up a config value to be automatically configured (Automatically handled by ConfigurableParameter)
     * @param key the yaml key the value will be found under in config.yml (in deploy folder)
     * @param parameter the parameter to update
     * @param simRealSpecific whether the value should be part of sim/real sub categories (true), or if it is universal (false)
     */
    public static void registerParameter(String key, Configurable<?> parameter, boolean simRealSpecific){
        configValues.put((simRealSpecific ? realOrSim() : "") + key, parameter);
        reload();
    }

    private static void reloadFromFile(){
        try {
            config = Yaml.createYamlInput(new File(Filesystem.getDeployDirectory() + "/config.yml")).readYamlMapping();
            pendingASUpdate = true;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void reloadConfig(){
        for(String key : configValues.keySet()){
            config = ensureExists(key, configValues.get(key).get().toString(), config);
            String[] keys = key.split("/");
            setValue(configValues.get(key), keys[keys.length - 1], getNestedValue(key, config));                 
        }
    }
    @SuppressWarnings("unchecked")
    private static void setValue(Configurable<?> obj, String key, YamlMapping map){
        if(obj.get() instanceof Double){
            ((Configurable<Double>)obj).set(Double.valueOf(map.doubleNumber(key)));
        } else if(obj.get() instanceof Integer){
            ((Configurable<Integer>)obj).set(Integer.valueOf(map.integer(key)));
        } else if(obj.get() instanceof Boolean){
            ((Configurable<Boolean>)obj).set(Boolean.valueOf(map.string(key)));
        } else if(obj.get() instanceof String){
            ((Configurable<String>)obj).set(String.valueOf(map.string(key)));
        } else {
            System.out.println("Unknown AutoConfig type: " + obj.get().getClass().getName());
        }
    }

    /**
     * Ensures that the given key exists in the given YamlMapping, and if it does not, adds it with the given default value. 
     * Will not overwrite any existing values, even in higher levels of the heirarchy
     * @param key The key to ensure exists, in the form of "key1/key2/key3"
     * @param defaultVal The default value to use if the key does not exist
     * @param source The YamlMapping to check
     * @return A new YamlMapping that is garunteed to have the given key
     */
    private static YamlMapping ensureExists(String key, String defaultVal,  final YamlMapping source) {
        String[] keys = key.split("/");
        // If the key already exists, return the original mapping
        YamlMapping nested = getNestedValue(key, source);
        if(nested != null && nested.string(keys[keys.length - 1]) != null){
            return source;
        }
        hasModified = true;
        pendingASUpdate = true;

        YamlMappingBuilder newMap = Yaml.createYamlMappingBuilder();
        newMap = newMap.add(keys[keys.length - 1], Yaml.createYamlScalarBuilder()
            .addLine(defaultVal)
            .buildPlainScalar(
                "Auto-generated"
            ));
            

        // Iterate backwards through the keys, creating the heirarchy from the bottom up
        for(int i = keys.length - 2; i >= 0; i--){
            newMap = Yaml.createYamlMappingBuilder().add(keys[i], newMap.build());
        }
        YamlMapping test = new MergedYamlMapping(source, newMap.build(), true);
        return test;
    }

    /**
     * Change the value of a key
     * @param key The key to change, in the form of "key1/key2/key3"
     * @param newValue The new value
     * @param source The YamlMapping to check
     * @return A new YamlMapping that is garunteed to have the given key
     */
    private static YamlMapping modifyValue(String key, String newValue, final YamlMapping source) {
        String[] keys = key.split("/");
        hasModified = true;
        pendingASUpdate = true;

        YamlMappingBuilder newMap = Yaml.createYamlMappingBuilder();
        newMap = newMap.add(keys[keys.length - 1], Yaml.createYamlScalarBuilder()
            .addLine(newValue)
            .buildPlainScalar(
                "Auto-generated (From In Control)"
            ));
            

        // Iterate backwards through the keys, creating the heirarchy from the bottom up
        for(int i = keys.length - 2; i >= 0; i--){
            newMap = Yaml.createYamlMappingBuilder().add(keys[i], newMap.build());
        }
        YamlMapping test = new MergedYamlMapping(source, newMap.build(), true);
        return test;
    }

    /**
     * Returns the mapping that is one step up in the hiearchy from the given key
     * @param key The key to get, in the form of "key1/key2/key3"
     * @param source The YamlMapping to get the key from
     * @return The nested YamlMapping, null if not found
     */
    private static YamlMapping getNestedValue(String key, YamlMapping source){
        String[] keys = key.split("/");
        YamlMapping map = source;
        for(int i = 0; i < keys.length - 1; i++){
            if(map == null) return map;
            map = map.yamlMapping(keys[i]);
        }
        return map;
    }

    /**
     * @return "real/" if the robot is real, "sim/" if the robot is simulated
     */
    public static String realOrSim() {
        return RobotBase.isReal() ? "real/" : "sim/";
    }


    /**
     * Reading/writing the config over networktables, used for the tuning and config GUI's built in to our modified advantage scope.
     * AutoConfig can be run without this if you aren't interested in these features. Designed to be run in periodic.
     */
    public static void runNTInterface(){
        String keySetRaw = NT4Interface.getSetKeys();
        if(!keySetRaw.isEmpty()){
            String[] keySet = keySetRaw.split(",");
            config = modifyValue(keySet[0], keySet[1], config);
            reload();
        }
        if(pendingASUpdate){
            pendingASUpdate = false;
            NT4Interface.updateConfig(config.toString());
            NT4Interface.updateClasses(configurableClasses);
        }
    }
}
 